#!/usr/bin/env node
const fs            = require("fs");
const path          = require("path");
const m2j           = require("md-2-json");
const marked        = require("marked");
const config_path   = process.argv[2];
const raw_md_config = fs.readFileSync(config_path).toString()
const raw_config    = marked.lexer(raw_md_config)
const config        = {}



const tmp = raw_config
  .reduce((a, b) => {
    let r = a;
    switch(b.type) {
      case "heading":
        let _path = a.path
        if(_path.length >= b.depth) _path = _path.slice(0, b.depth -1)
        _path.reduce((_o, i) => _o[i], a.o)[b.text] = {};
        r = {
          ...a,
          path: _path.concat(b.text),
          o: a.o
        }
        break;
      case "code":
        let e = a.path.reduce((_o, i) => _o[i], a.o);
        e.data = (e.data || []).concat([b.text])
        r = a
        break;
      default:
        break;
    }
    return r;
  }, {
    path: [],
    o: {}
  })


let toObject = (str, d = ":") => str
  .split("\n")
  .map(e => e.split(d))
  .reduce((a, [k, v]) => { a[k.trim()] = v.trim(); return a; }, {})

let toStorage = str => str.split("\n")

let lvl1_config = tmp.o[Object.keys(tmp.o)[0]]
const global_vars   = toObject(lvl1_config.defaults.vars.data[0]);
const global_stores = toObject(lvl1_config.defaults.storage.data[0], "|->");




const filename      = path.basename(config_path, ".md");
const abifile_name  = "dss/out/Lad.abi"; // TODO

const template      = fs.readFileSync("./template.ini")
  .toString();
const render        = o => Object.keys(o)
  .reduce((tmp, name) =>
    tmp.replace(new RegExp("{{" + name + "}}", "g"), o[name]), template)

const bound = {
  "uint256": name => `#rangeUInt(256, ${ name })`,
  "int256" : name => `#rangeSInt(256, ${ name })`,
  "bytes32": name => `#rangeBytes(32, ${ name })`,
  "address": name => `#rangeAddress(${ name })`
}


const abi = JSON.parse(fs.readFileSync(abifile_name));

const make_abi_dsl = ({type, name}, i) =>
  "#" + type + "(ABI_" + name + ")"
const make_args = inputs => inputs.length == 0
    && ".TypedArgs"
    || inputs.map(make_abi_dsl).join(", ")


let abit = Object.keys(lvl1_config.methods)
  .map(name => ({
    vars: lvl1_config.methods[name].vars && toObject(lvl1_config.methods[name].vars.data[0]) || {},
    stores: lvl1_config.methods[name].storage && toObject(lvl1_config.methods[name].storage.data[0] , "|->") || [],
    requires: lvl1_config.methods[name].requires && toStorage(lvl1_config.methods[name].requires.data[0]) || [],
    returns: lvl1_config.methods[name].returns && lvl1_config.methods[name].returns.data[0] || "",
    foreign_stores: lvl1_config.methods[name].foreign_stores,
    abi: name.indexOf("(") == -1
           ? abi.find(fabi => fabi.name == name)
           : abi.find(fabi => fabi.name + "(" + fabi.inputs.map(i => i.type).join(",") + ")" == name )
  }))
  .filter(({abi}) => abi.type == "function")
  .map(({abi, vars, stores, requires, returns, foreign_stores}) => {

    const local_vars = {
      ...global_vars,
      ...vars
    }
    const local_stores = {
      ...global_stores,
      ...stores
    }

    const storage_success = "  " + Object.keys(local_stores)
      .map(key => key + " |-> (" + local_stores[key] + ")" )
      .join("\n  ")

    const vars_in_range = Object.keys(local_vars)
      .map(name => `andBool ${bound[local_vars[name]](name)}`)


    let callData = `#abiCallData("${abi.name}", ${make_args(abi.inputs)})`
    let abi_var_in_range = abi.inputs
      .filter(({name}) => !local_vars["ABI_" + name])
      .map(({type, name}, i) => `andBool ${ bound[type]("ABI_" + name) }` )

    let fabi_success = (requires || [])
      .map(c => `andBool ` + c)
    let cond_success = (abi_var_in_range.length > 0 ? ["\n  // call data"] : [])
      .concat(abi_var_in_range)
      .concat(["\n  // storage data"])
      .concat(vars_in_range)
      .concat(["\n  // success conditions"])
      .concat(fabi_success)
      .join("\n  ")

    const storage_fail = "  " + Object.keys(local_stores)
      .map(key => key + " |-> " + (local_stores[key].indexOf("=>") > -1 ? "(" + local_stores[key].split("=>")[0] + "=> _)" : local_stores[key]) )
      .join("\n  ")
    let fabi_fail = ["notBool (\n            " + (requires || []).join("\n    andBool ") + "\n  )"]
      .map(c => `andBool ` + c)
    let cond_fail = (abi_var_in_range.length > 0 ? ["\n  // call data"] : [])
      .concat(abi_var_in_range)
      .concat(["\n  // storage data"])
      .concat(vars_in_range)
      .concat(["\n  // success conditions"])
      .concat(fabi_fail)
      .join("\n  ")


    let accounts = Object.keys(foreign_stores || {})
      .map(name => {
        let code = fs.readFileSync("dss/out/" + name + ".bin-runtime")
        let fstore = toObject(foreign_stores[name].data[0], "|->");
        let stores_ = Object.keys(fstore)
          .map(key => key + " |-> (" + fstore[key] + ")" )
          .join("\n  ")

        return `<account>
          <acctID> ${name} </acctID>
          <balance> _ </balance>
          <code> #parseByteStack("0x${code}") </code>
          <storage>
            ${stores_}
          </storage>
          <nonce> _ </nonce>
        </account>
        `
      })
      .join("\n")

    let activeaccounts = Object.keys(foreign_stores || {})
      .map(name => `SetItem(${name})`)
      .join(" ")


    const filename = abi.name + "_" + abi.inputs.map(i => i.type).join("_")

    let cases = [{
      name: "success_" + filename,
      spec: render({
        name: abi.name,
        callData,
        cond: cond_success,
        storage: storage_success,
        returns: returns || "_",
        status: "EVMC_SUCCESS",
        activeaccounts,
        accounts
      })
    }];

    if((requires || []).length > 0) {
      cases.push({
        name: "fail_" + filename,
        spec: render({
          name: abi.name,
          callData,
          cond: cond_fail,
          storage: storage_fail,
          returns: "_",
          status: "EVMC_REVERT",
          activeaccounts,
          accounts
        })
      })
    }
    return cases;

  })
  .reduce((a, cs) => a.concat(cs), [])

try {
  fs.accessSync("out", fs.constants.F_OK);
} catch (e) {
  fs.mkdirSync("out");
}

abit
  .forEach(({spec, name}) => {
    fs.writeFileSync("out/" + filename + "_" + name + ".ini", spec)
  })


// console.log(abit[0]);
